#!/bin/sh

set -e

. /usr/share/debconf/confmodule

_CONFFILE="/etc/default/linux-container"

case "${1}" in
	configure)
		db_get linux-container/enable
		LINUX_CONTAINER_ENABLE="${RET}" # boolean

		db_get linux-container/hostname
		LINUX_CONTAINER_HOSTNAME="${RET}" # string (w/o empty)

		db_get linux-container/dhcp
		LINUX_CONTAINER_DHCP="${RET}" # boolean

		if [ -z "${LINUX_CONTAINER_HOSTNAME}" ]
		then
			if [ -n "$(cat /etc/hostname 2> /dev/null)" ]
			then
				LINUX_CONTAINER_HOSTNAME="$(cat /etc/hostname)"
			elif [ -x /usr/bin/lsb_release ]
			then
				LINUX_CONTAINER_HOSTNAME="$(lsb_release -is | tr [A-Z] [a-z])"
			else
				LINUX_CONTAINER_HOSTNAME="debian"
			fi
		fi

		if [ "${LINUX_CONTAINER_DHCP}" = "false" ]
		then
			db_get linux-container/address
			LINUX_CONTAINER_ADDRESS="${RET:-192.168.0.1}" # string (w/o empty)

			db_get linux-container/broadcast
			LINUX_CONTAINER_BROADCAST="${RET}" # string (w/ empty)

			db_get linux-container/gateway
			LINUX_CONTAINER_GATEWAY="${RET}" # string (w/ empty)

			db_get linux-container/netmask
			LINUX_CONTAINER_NETMASK="${RET:-255.255.255.0}" # string (w/o empty)

			db_get linux-container/network
			LINUX_CONTAINER_NETWORK="${RET}" # string (w/ empty)

			db_get linux-container/nameservers
			LINUX_CONTAINER_NAMESERVERS="${RET}" # string (w/ empty)
		fi

		db_stop

		if [ ! -e "${_CONFFILE}" ]
		then

cat > "${_CONFFILE}" << EOF
# /etc/default/linux-container

LINUX_CONTAINER_ENABLE="${LINUX_CONTAINER_ENABLE}"
EOF
		fi

		cp -a -f "${_CONFFILE}" "${_CONFFILE}.tmp"

		# If the admin deleted or commented some variables but then set
		# them via debconf, (re-)add them to the config file.

		test -z "${LINUX_CONTAINER_ENABLE}" || \
		grep -Eq '^ *LINUX_CONTAINER_ENABLE=' "${_CONFFILE}" || \
		echo "LINUX_CONTAINER_ENABLE=" >> "${_CONFFILE}"

		sed     -e "s|^ *LINUX_CONTAINER_ENABLE=.*|LINUX_CONTAINER_ENABLE=\"${LINUX_CONTAINER_ENABLE}\"|" \
		< "${_CONFFILE}" > "${_CONFFILE}.tmp"

		mv -f "${_CONFFILE}.tmp" "${_CONFFILE}"

		if [ "${LINUX_CONTAINER_ENABLE}" != "true" ]
		then
			exit 0
		fi

		# Applying bug fixes
		if [ -x /usr/bin/lsb_release ]
		then
			_DISTRIBUTOR="$(lsb_release -is | tr [A-Z] [a-z])"
			_CODENAME="$(lsb_release -cs | tr [A-Z] [a-z])"
		else
			if [ -e /etc/progress_version ]
			then
				_DISTRIBUTOR="progress"
				_VERSION="$(awk -F. '{ print $1 "." $2 }' /etc/progress_version)"

				case "${_VERSION}" in
					1.0)
						_CODENAME="artax"
						;;

					1.9)
						_CODENAME="artax-backports"
						;;

					2.0)
						_CODENAME="baureo"
						;;
				esac
			elif [ -e /etc/debian_version ]
			then
				_DISTRIBUTOR="debian"

				if grep -qs sid /etc/debian_version
				then
					_CODENAME="sid"
				else
					_VERSION="$(awk -F. '{ print $1 "." $2 }' /etc/debian_version)"
				fi

				case "${_VERSION}" in
					6.0)
						_CODENAME="squeeze"
						;;

					7.0)
						_CODENAME="wheezy"
						;;
				esac
			fi
		fi

		if ls "/usr/share/linux-container/bugs/${_DISTRIBUTOR}-${_CODENAME}"/* > /dev/null 2>&1
		then
			for _SCRIPT in "/usr/share/linux-container/bugs/${_DISTRIBUTOR}-${_CODENAME}"/*
			do
				./"${_SCRIPT}"
			done
		fi

		# squeeze only has /dev/tty and /dev/tty0 by default,
		# therefore creating missing device nodes for tty1-4.
		for tty in $(seq 1 4)
		do
			if [ ! -e /dev/tty$tty ]
			then
				mknod /dev/tty$tty c 4 $tty
			fi
		done

		# setup /etc/inittab

cat > /etc/inittab << EOF
id:2:initdefault:
si::sysinit:/etc/init.d/rcS
l0:0:wait:/etc/init.d/rc 0
l1:1:wait:/etc/init.d/rc 1
l2:2:wait:/etc/init.d/rc 2
l3:3:wait:/etc/init.d/rc 3
l4:4:wait:/etc/init.d/rc 4
l5:5:wait:/etc/init.d/rc 5
l6:6:wait:/etc/init.d/rc 6
# Normally not reached, but fallthrough in case of emergency.
z6:6:respawn:/sbin/sulogin
1:2345:respawn:/sbin/getty 38400 console
c1:12345:respawn:/sbin/getty 38400 tty1 linux
c2:12345:respawn:/sbin/getty 38400 tty2 linux
c3:12345:respawn:/sbin/getty 38400 tty3 linux
c4:12345:respawn:/sbin/getty 38400 tty4 linux
EOF

		# add daemontools-run entry
		if [ -e /var/lib/dpkg/info/daemontools.list ]
		then

cat >> /etc/inittab << EOF
#-- daemontools-run begin
SV:123456:respawn:/usr/bin/svscanboot
#-- daemontools-run end
EOF

		fi

		# disable selinux
		mkdir -p /selinux
		echo 0 > /selinux/enforce

		# configure the network
		if [ "${LINUX_CONTAINER_DHCP}" = "false" ]
		then

cat > /etc/hosts << EOF
127.0.0.1	localhost
${LINUX_CONTAINER_ADDRESS}	${LINUX_CONTAINER_HOSTNAME}
::1		localhost ip6-localhost ip6-loopback
fe00::0		ip6-localnet
ff00::0		ip6-mcastprefix
ff02::1		ip6-allnodes
ff02::2		ip6-allrouters
EOF

		fi

cat > /etc/network/interfaces << EOF
# This file describes the network interfaces available on your system
# and how to activate them. For more information, see interfaces(5).

# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
EOF

		case "${LINUX_CONTAINER_DHCP}" in
			true)

cat >> /etc/network/interfaces << EOF
iface eth0 inet dhcp
EOF

				;;

			false)

cat >> /etc/network/interfaces << EOF
iface eth0 inet static
	address ${LINUX_CONTAINER_ADDRESS}
EOF

				if [ -n "${LINUX_CONTAINER_BROADCAST}" ]
				then
					echo "	broadcast ${LINUX_CONTAINER_BROADCAST}" >> /etc/network/interfaces
				fi

				if [ -n "${LINUX_CONTAINER_GATEWAY}" ]
				then
					echo "	gateway ${LINUX_CONTAINER_GATEWAY}" >> /etc/network/interfaces
				fi

				echo "	netmask ${LINUX_CONTAINER_NETMASK}" >> /etc/network/interfaces

				if [ -n "${LINUX_CONTAINER_NETWORK}" ]
				then
					echo "	network ${LINUX_CONTAINER_NETWORK}" >> /etc/network/interfaces
				fi

				if [ -n "${LINUX_CONTAINER_NAMESERVERS}" ]
				then
					rm -f /etc/resolv.conf

					for _NAMESERVER in $(echo ${LINUX_CONTAINER_NAMESERVERS} | sed -e 's|,| |g')
					do
						echo "nameserver ${_NAMESERVER}" >> /etc/resolv.conf
					done
				fi
				;;
		esac

		# set the hostname
		echo "${LINUX_CONTAINER_HOSTNAME}" > /etc/hostname

		# remove pointless services in a container
		update-rc.d -f checkroot.sh remove \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'
		update-rc.d checkroot.sh stop 09 S . \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'

		update-rc.d -f umountfs remove \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'
		update-rc.d umountfs start 09 0 6 . \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'

		update-rc.d -f umountroot remove \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'
		update-rc.d umountroot start 10 0 6 . \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'

		# The following initscripts don't provide an empty start or stop block.
		# To prevent them being enabled on upgrades, we leave a start link on
		# runlevel 3.
		update-rc.d -f hwclock.sh remove \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'
		update-rc.d hwclock.sh start 10 3 . \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'

		update-rc.d -f hwclockfirst.sh remove \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'
		update-rc.d hwclockfirst.sh start 08 3 . \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'

		update-rc.d -f module-init-tools remove \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'
		update-rc.d module-init-tools start 10 3 . \ |
		grep -v 'update-rc.d: using dependency based boot sequencing'
		;;

	abort-upgrade|abort-remove|abort-deconfigure)

		;;

	*)
		echo "postinst called with unknown argument \`${1}'" >&2
		exit 1
		;;
esac

#DEBHELPER#

exit 0
